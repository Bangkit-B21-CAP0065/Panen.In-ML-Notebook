# -*- coding: utf-8 -*-
"""Forecast_revisi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eKC804mg_Q_Okg6PHrykiHJa2EIi6Ij-
"""

import tensorflow as tf
import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import joblib

files = os.listdir(r'/content/drive/MyDrive/Data Cuaca/Stasiun Bandung/')
files.sort()
kolom = ['Tn','Tx','Tavg','RH_avg','RR','ss','ff_x','ddd_x','ff_avg']
df_bandung = pd.DataFrame(columns = kolom)

for file in files :
  a = pd.read_excel(r'/content/drive/MyDrive/Data Cuaca/Stasiun Bandung/' + file,na_values = [8888,9999,"NaN"],header=8)
  a.dropna(axis=0,inplace=True)
  df_bandung = df_bandung.append({'Tn':a.mean()[0],'Tx':a.mean()[1],'Tavg':a.mean()[2],'RH_avg':a.mean()[3],'RR':a.mean()[4],
                'ss':a.mean()[5],'ff_x':a.mean()[6],'ddd_x':a.mean()[7],'ff_avg':a.mean()[8]},ignore_index = True)

df_bandung = df_bandung.interpolate(method ='linear', limit_direction ='forward')  
ff_x = df_bandung.pop('ff_x')
ddd_x = df_bandung.pop('ddd_x')

wd_rad = ddd_x*np.pi / 180

df_bandung['ff_x'] = ff_x*np.cos(wd_rad)
df_bandung['ff_y'] = ff_x*np.sin(wd_rad)

df_bandung

files = os.listdir(r'/content/drive/MyDrive/Data Cuaca/Stasiun Bogor/')
files.sort()
kolom = ['Tn','Tx','Tavg','RH_avg','RR','ss','ff_x','ddd_x','ff_avg']
df_bogor = pd.DataFrame(columns = kolom)

for file in files :
  a = pd.read_excel(r'/content/drive/MyDrive/Data Cuaca/Stasiun Bogor/' + file,na_values = [8888,9999,"NaN"],header=8)
  a.dropna(axis=0,inplace=True)
  df_bogor = df_bogor.append({'Tn':a.mean()[0],'Tx':a.mean()[1],'Tavg':a.mean()[2],'RH_avg':a.mean()[3],'RR':a.mean()[4],
                'ss':a.mean()[5],'ff_x':a.mean()[6],'ddd_x':a.mean()[7],'ff_avg':a.mean()[8]},ignore_index = True)

df_bogor = df_bogor.interpolate(method ='linear', limit_direction ='forward')  
ff_x = df_bogor.pop('ff_x')
ddd_x = df_bogor.pop('ddd_x')

wd_rad = ddd_x*np.pi / 180

df_bogor['ff_x'] = ff_x*np.cos(wd_rad)
df_bogor['ff_y'] = ff_x*np.sin(wd_rad)

df_bogor

column_indices_bandung = {name: i for i, name in enumerate(df_bandung.columns)}

n = len(df_bandung)
print(n)
train_df_bandung = df_bandung[0:int(n*0.8)]
val_df_bandung = df_bandung[int(n*0.8):]

num_features = df_bandung.shape[1]
val_df_bandung

column_indices_bogor = {name: i for i, name in enumerate(df_bogor.columns)}

n = len(df_bogor)
print(n)
train_df_bogor = df_bogor[0:int(n*0.8)]
val_df_bogor = df_bogor[int(n*0.8):]

num_features = df_bogor.shape[1]
val_df_bogor

class WindowGenerator():
  def __init__(self, input_width, label_width, shift,
               train_df, val_df,df,
               label_columns=None):
    self.train_df = train_df
    self.val_df = val_df
    self.df = df

    self.label_columns = label_columns
    if label_columns is not None:
      self.label_columns_indices = {name: i for i, name in
                                    enumerate(label_columns)}
    self.column_indices = {name: i for i, name in
                           enumerate(train_df.columns)}

    self.input_width = input_width
    self.label_width = label_width
    self.shift = shift

    self.total_window_size = input_width + shift

    self.input_slice = slice(0, input_width)
    self.input_indices = np.arange(self.total_window_size)[self.input_slice]

    self.label_start = self.total_window_size - self.label_width
    self.labels_slice = slice(self.label_start, None)
    self.label_indices = np.arange(self.total_window_size)[self.labels_slice]

  def __repr__(self):
    return '\n'.join([
        f'Total window size: {self.total_window_size}',
        f'Input indices: {self.input_indices}',
        f'Label indices: {self.label_indices}',
        f'Label column name(s): {self.label_columns}'])

width = 4
bandung = WindowGenerator(input_width=width, label_width=1, shift=1,train_df =  train_df_bandung,val_df = val_df_bandung, df = df_bandung )
bogor =  WindowGenerator(input_width=width, label_width=1, shift=1,train_df =  train_df_bogor,val_df = val_df_bogor, df = df_bogor )

bandung
bogor

def split_window(self, features):
  inputs = features[:, self.input_slice, :]
  labels = features[:, self.labels_slice, :]
  if self.label_columns is not None:
    labels = tf.stack(
        [labels[:, :, self.column_indices[name]] for name in self.label_columns],
        axis=-1)

  inputs.set_shape([None, self.input_width, None])
  labels.set_shape([None, self.label_width, None])

  return inputs, labels

WindowGenerator.split_window = split_window

def make_dataset(self, data):
  data = np.array(data, dtype=np.float32)
  ds = tf.keras.preprocessing.timeseries_dataset_from_array(
      data=data,
      targets=None,
      sequence_length=self.total_window_size,
      sequence_stride=1,
      shuffle=True,
      batch_size=2)

  ds = ds.map(self.split_window)

  return ds

WindowGenerator.make_dataset = make_dataset

@property
def train(self):
  return self.make_dataset(self.train_df)

@property
def val(self):
  return self.make_dataset(self.val_df)

WindowGenerator.train = train
WindowGenerator.val = val

model_bandung = tf.keras.Sequential([
    tf.keras.layers.Conv1D(filters=32,
                           kernel_size=(width,),
                           activation='relu'),
    tf.keras.layers.Dense(units=16, activation='relu'),
    tf.keras.layers.Dense(units=32, activation='relu'),
    tf.keras.layers.Dense(units=num_features),
])

model_bogor = tf.keras.Sequential([
    tf.keras.layers.Conv1D(filters=32,
                           kernel_size=(width,),
                           activation='relu'),
    tf.keras.layers.Dense(units=16, activation='relu'),
    tf.keras.layers.Dense(units=32, activation='relu'),
    tf.keras.layers.Dense(units=num_features),
])

epochs = 20

model_bandung.compile(loss=tf.losses.MeanSquaredError(),
                optimizer=tf.optimizers.Adam(0.001),
                metrics=[tf.metrics.MeanAbsoluteError()])

history_bandung = model_bandung.fit(bandung.train, epochs=epochs,
                      validation_data=bandung.val)

model_bogor.compile(loss=tf.losses.MeanSquaredError(),
                optimizer=tf.optimizers.Adam(0.001),
                metrics=[tf.metrics.MeanAbsoluteError()])

history_bogor = model_bogor.fit(bogor.train, epochs=epochs,
                      validation_data=bogor.val)

def forecast(subround,location,model_bandung=model_bandung,model_bogor=model_bogor) :
  output  =  []
  df_bandung_copy = df_bandung.copy()
  df_bogor_copy = df_bogor.copy()
  if location == 'Kab.Bandung'  :
    for i in range(subround):
      input = df_bandung_copy[-width:]
      input_forecast = np.array(input)[np.newaxis]
      temp = model_bandung.predict(input_forecast)
      
      temp = np.squeeze(temp, axis=None)
      output.append(temp)
      df_bandung_copy = df_bandung_copy.append(pd.DataFrame([temp], columns=['Tn','Tx','Tavg','RH_avg','RR','ss','ff_avg','ff_x','ff_y']))
      print(df_bandung_copy)
  if location == 'Kab.Bogor'  :
    for i in range(subround):
      input = df_bogor_copy[-width:]
      input_forecast = np.array(input)[np.newaxis]
      temp = model_bandung.predict(input_forecast)
      temp = np.squeeze(temp, axis=None)
      output.append(temp)
      df_bogor_copy = df_bandung_copy.append(pd.DataFrame([temp], columns=['Tn','Tx','Tavg','RH_avg','RR','ss','ff_avg','ff_x','ff_y']))
      print(df_bandung_copy)
  return output

output = forecast(3,'Kab.Bandung')
print(output)

# save dataframe
df_bandung.to_csv('./df_bandung.csv')
df_bogor.to_csv('./df_bogor.csv')

# Save model
model_bandung.save('./model_bandung.h5')
model_bogor.save('./model_bogor.h5')